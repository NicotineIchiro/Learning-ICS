The "vim -t" is not always reliable, sometimes would jump to same name function in different directory.

The vaddr_read reads multiple words , concating begin at high address, with every word LITTLE-ENDIAN(end byte at end)



The cross-file function action can be declared by extra header file or extern(Non-static);

现阶段单目运算符还无法支持表达式！

负数繁分数有问题！（因暂时以无符号int存储补码负数编码）

KISS: 先做PA2吧。目前cmd_p Error率在1%～2%,尚可容忍。之后每天寻找cmd_p的问题。

指令实现：根据功能（立即数编码/整数计算/控制转移/内存加载与存储/Memory Ordering/Environmental call & breakpoints）
								以及操作数个数和类型两方面，在手册的Instruction Set章节中寻找参考指令格式。

rv-E的JAL是jump and link,不是above...，不要以x86的认知想当然!
	采用相对寻址。

当明显会出问题的基本操作都没报error时，
	问题可能出在根本就忘了调用/参数没传对。
	换句话说，当你感觉系统犯病了时，往往犯病的是你（的程序）。

p功能在*(reg)时有bug，会报符号不匹配

注意指令实现时宏展开后的寻址次数。

在无法实现打印的情况下，对于多次重复调用的程序，可在main函数各次调用之间打断点，从而检查每一次的可达性。

检查汇编代码时总要注意操作数类型！有无立即数完全不同！
	特别是反汇编显示的指令名与手册规范有出入！
	显示的操作数也有出入，一切以实际编码情况为准。

jal和sd实现有问题。

逻辑上不难，但涉及到接口规范的库函数，仔细阅读手册描述和示例的每一处，不要自以为是随意推广！

已解决：div实现是否有问题？pa2.2 hello-str中使用int作索引，不出问题，使用size_t作索引，死循环。
	确实。在size_t下的右移会错误地使用其他指令，因未实现srli,由于int是32位，int下会正确使用已实现的srliw。

	心得：		
		在基础设施未完备的情况下，出现问题如果在高层排查不出，则逐步向下排查。具体来说目前可以通过trace log来捕捉异常指令流轨迹，从而判断是否存在错误译码、指令未实现等问题。
		一般步骤：自main向内，在本层的各函数调用之间打监视点检查可达性，遇到不可达处则循其之前最后一个函数调用，递归向下重复此过程，从而确定问题所在函数。最后确定问题所在指令范围后再逐指令、寄存器排查，避免一开始就陷入细节，于事无补、空耗时间。对于明显极端异常值的，可对相关寄存器进行监视，从而排查是否是指令实现的缺漏等。

如果构建时加入了debug选项但gdb无法查看源码，不要着急认为“没加入调试符号”，先从反汇编文件入手看看函数信息是否正确，只要函数正确即可通过layout asm逐步调试，layout src可遇不可求。

对于边界情况宁可冗余处理也不要偷漏步！

?为什么自己load_elf会是内置镜像？
	成功把elf传给了NEMU，但没有成功加载到内存中。

对于fseek, ftell, fread行为理解不透彻->RTFM，弄清楚参数和基本行为。
