The "vim -t" is not always reliable, sometimes would jump to same name function in different directory.

The vaddr_read reads multiple words , concating begin at high address, with every word LITTLE-ENDIAN(end byte at end)



The cross-file function action can be declared by extra header file or extern(Non-static);

现阶段单目运算符还无法支持表达式！

负数繁分数有问题！（因暂时以无符号int存储补码负数编码）

KISS: 先做PA2吧。目前cmd_p Error率在1%～2%,尚可容忍。之后每天寻找cmd_p的问题。

指令实现：根据功能（立即数编码/整数计算/控制转移/内存加载与存储/Memory Ordering/Environmental call & breakpoints）
								以及操作数个数和类型两方面，在手册的Instruction Set章节中寻找参考指令格式。

rv-E的JAL是jump and link,不是above...，不要以x86的认知想当然!
	采用相对寻址。

当明显会出问题的基本操作都没报error时，
	问题可能出在根本就忘了调用/参数没传对。
	换句话说，当你感觉系统犯病了时，往往犯病的是你（的程序）。

p功能在*(reg)时有bug，会报符号不匹配

注意指令实现时宏展开后的寻址次数。

在无法实现打印的情况下，对于多次重复调用的程序，可在main函数各次调用之间打断点，从而检查每一次的可达性。

检查汇编代码时总要注意操作数类型！有无立即数完全不同！
	特别是反汇编显示的指令名与手册规范有出入！
	显示的操作数也有出入，一切以实际编码情况为准。

jal和sd实现有问题。

逻辑上不难，但涉及到接口规范的库函数，仔细阅读手册描述和示例的每一处，不要自以为是随意推广！

已解决：div实现是否有问题？pa2.2 hello-str中使用int作索引，不出问题，使用size_t作索引，死循环。
	确实。在size_t下的右移会错误地使用其他指令，因未实现srli,由于int是32位，int下会正确使用已实现的srliw。

	心得：		
		在基础设施未完备的情况下，出现问题如果在高层排查不出，则逐步向下排查。具体来说目前可以通过trace log来捕捉异常指令流轨迹，从而判断是否存在错误译码、指令未实现等问题。
		一般步骤：自main向内，在本层的各函数调用之间打监视点检查可达性，遇到不可达处则循其之前最后一个函数调用，递归向下重复此过程，从而确定问题所在函数。最后确定问题所在指令范围后再逐指令、寄存器排查，避免一开始就陷入细节，于事无补、空耗时间。对于明显极端异常值的，可对相关寄存器进行监视，从而排查是否是指令实现的缺漏等。

如果构建时加入了debug选项但gdb无法查看源码，不要着急认为“没加入调试符号”，先从反汇编文件入手看看函数信息是否正确，只要函数正确即可通过layout asm逐步调试，layout src可遇不可求。

对于边界情况宁可冗余处理也不要偷漏步！

?为什么自己load_elf会是内置镜像？
	成功把elf传给了NEMU，但没有成功加载到内存中。

	->对于fseek, ftell, fread行为理解不透彻->RTFM，弄清楚参数和基本行为。

ELF文件的结构：
	ELF file header: Elf_[32|64]Ehdr (Always at the offset ZERO)

	then
	Section Header or Program Header or both
	The offset of above header are defined in ELF header.
		By the e_phoff and e_shoff in Elf_Ehdr

	Section header:  Elf_[32|64]Shdr							 AN ARRAY OF Elf_[32|64]Shdr
	Program Header:(only in executable or relocable. )  AN ARRAY OF Elf_[32|64]Phdr 
		Size specified by Elf_Ehdr.ephntsize and num by Elf_Ehdr.e_phnum
		Member p_offset is the ? to file?
	String and Symbol tables (one of the sections.)


? .text开头究竟要从Section Header还是SymTab获取？
	从section header的sh_off获取。

但如何得知section header对应.text?
	 ？ 如何找到symtab/strtab开头？
	通过Elf_Nhdr->e_shstrndx? 但该项为.shstrtab的索引。
	看起来&.shstrtab + sh_name即为段名字符串开头。  另外,shstrtab似乎不可读。因此需要fread。
	但strtab和shstrtab区别是什么?
	以及如何找到strtab、symtab的位置？
所有文件IO后都应该assert吗？ 是的，首先帮助解决Fault.

？symtab和strtab读取后为空 <- 对应的shdr offset甚至超出文件大小?怎么回事？
offset仍然超出，但将fread参数按手册定义修正后能够正确打印strtab：
	RTFM，RTFM，RTFM，最初可以对已有代码照猫画虎，但明白大致功能后严格按定义操作。	
仍然没有正确读取Symtab！
Strtab前半段读对了，但尺寸也不对，说明shtp的读取有问题。

注意：Symtab条目Elf64_Sym的st_shndx包含符号通往section header tables 的索引！
?Symbol table 是不是连续的？
读取有问题是否和align有关？align是否会影响结构数组的整体布局？
彻底RTFM！ ElfN_Shdr->sh_entsize 对于本身为复合类型数组的Section规定了其每个元素的尺寸。
从fhdr读取就有问题了！e_machine! 
	补充： e_machine没问题 看起来没有按文档说的四字节对齐

e_entry的含义：系统首次移交控制的虚拟地址？

...目前看起来，读取section header array没有问题，只是一直误以为加载的是add，实际上加载了hello。
	当数值看起来明显反常（例如超出程序边界时），不要钻牛角尖硬调，gdb打印不了的内存区域直接hd逐字节对照。
